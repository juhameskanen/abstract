\chapter{Black Holes: From Something to Nothing}

A computer running a simulation and the simulated universe can be viewed as two perspectives of the same information. 
We can apply this principle to black hole singularities by treating the computer simulation and the simulated black hole 
as equivalent descriptions of the same informational structure. This may provide insight into the mysterious pathological points of spacetime.

\section{Execution Trace}

Computers are state machines. Each executed CPU instruction drives the system to a new state. 
In software engineering, an \textbf{execution trace} is the chronological record of all such states. 
If source code is a map, the execution trace is the complete GPS log of every step taken.

\section{The Simulation}

Consider a simulation of a massive, spherical dust cloud collapsing under its own gravity to form a black hole.
In practice, we cannot run this simulation to its logical conclusion—the formation of a singularity.
As the collapse nears its final state, the software inevitably crashes.
This failure is driven by two factors: the fundamental breakdown of the Einstein field equations and the inherent limitations of our digital tools.
Long before the singularity is reached, the system is overwhelmed by division-by-zero exceptions and mathematical infinities that exceed the numerical precision of our floating-point representations.

General Relativity predicts singularities, but it fails to describe them.

\begin{figure}[h!]
\centering
\includegraphics[width=1.0\textwidth]{figures/schwarzschild.png}
\caption{Execution-trace entropy of particles falling into a Schwarzschild black hole.}
\end{figure}


However, each dust particle and spacetime fabric point in this simulation can be mapped to a sequence of memory bits. 
Together, the particles form a long continuous bitstring representing a temporal slice of the simulation.
So let us study this information theoretical correspondence of the black hole - its so called execution trace. 

Initially, the bitstring appears very random:

\begin{verbatim}
00100101011110101010101001010100101010101010101001001001110101010010100101010...
...
\end{verbatim}

Entropy quantifies the randomness of this bitstring—the number of ways the bits can be rearranged to produce the same macroscopic configuration, 
here the dust cloud and its corresponding spacetime metric as described by General Relativity.

As the simulation evolves, measuring the entropy of the bitstring over time shows a monotonic decrease. 
Even if numerical instabilities prevent the simulation from reaching the final singularity, it does not matter. We can
draw the necessary conclusion by extrapolating the execution trace:

\begin{verbatim}
...
0001000010000010010001000000001000100000000000001000010000000010000000100010000...
0001001000000000010000000000000010000010000000001000000000000000000100000000001...
0000001000000000000000000000001000000000000000000000100001000000000000000000100...
[crash]
\end{verbatim}

The singularity corresponds to a zero-entropy state.

\subsection{Formal Description}

Let $\mathcal{M}$ denote the set of all memory locations in a deterministic computing system. 
A \emph{machine state} $\mathcal{S} \in \mathcal{M}$ is a complete assignment of values to all memory elements. 
Let $\mathcal{P} = (I_1, I_2, \dots, I_n)$ be a sequence of deterministic instructions, 
with $I_k : \mathcal{S} \rightarrow \mathcal{S}$. 

The execution trace $\mathcal{T}$ is the ordered sequence:

\[
\mathcal{T} = (s_0, s_1, \dots, s_n), \quad s_{k+1} = I_{k+1}(s_k).
\]

This trace encodes the full informational evolution of the simulated geometry.

\subsection{Mapping Geometry to Bitstrings}

A geometric configuration can be encoded as a bitstring $b \in \{0,1\}^L$, 
representing discretized particle positions in the collapsing cloud. 
Define the configuration space:

\[
C = \{0,1\}^{3k},
\]

with a decoding map

\[
f : C \to \mathbb{Z}^3
\]

that converts fixed-length binary segments into integer coordinates. 
Quantization ensures that entropy reflects genuine positional distinctions.

\subsection{Shannon Entropy}

The Shannon entropy of the bitstring is

\[
H(b) = -p_0 \log_2 p_0 - p_1 \log_2 p_1,
\]

where $p_0$ and $p_1$ are empirical bit frequencies. 
Across the execution trace, $H(b)$ decreases as particles converge.

Even though the classical simulation crashes at the singularity due to divergences, the entropy trajectory can be smoothly extrapolated:

\[
H(\mathcal{B}_t) \to 0.
\]

Zero entropy implies $W = 1$: only one distinguishable configuration remains.


\section{Conclusion}

Singularities may be interpreted as points of zero entropy rather than merely infinite curvature. 
In classical GR, curvature diverges as geodesics converge, but this may reflect the limits of the geometric description rather than a physical
pathology—analogous to measuring surface derivatives at the north pole of a sphere.

Remarkably, the zero-entropy conclusion is invariant under coordinate choice, representation, or dimensionality. 
Mapping zero entropy bitstring to geometry inevitably yields the same minimal object: a point. 

Thus, singularities are not mysterious infinities but the simplest possible geometric configurations: 
states of informational exhaustion. They represent the ultimate compression of all degrees of freedom in a region of spacetime.
